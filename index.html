<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>LLM Prompt Energy Efficiency Score</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #050816;
      --card: #0b1120;
      --accent: #38bdf8;
      --accent-soft: rgba(56, 189, 248, 0.15);
      --text: #e5e7eb;
      --text-muted: #9ca3af;
      --danger: #f97373;
      --warning: #facc15;
      --success: #4ade80;
    }

    * {
      box-sizing: border-box;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        "Segoe UI", sans-serif;
    }

    body {
      margin: 0;
      padding: 0;
      min-height: 100vh;
      background: radial-gradient(circle at top, #1e293b 0, #020617 55%, #020617 100%);
      color: var(--text);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .app-shell {
      width: 100%;
      max-width: 1100px;
      margin: 24px;
      padding: 24px;
      border-radius: 24px;
      background: linear-gradient(145deg, rgba(15,23,42,0.95), rgba(15,23,42,0.75));
      box-shadow:
        0 24px 60px rgba(15, 23, 42, 0.85),
        0 0 0 1px rgba(148, 163, 184, 0.15);
      backdrop-filter: blur(18px);
    }

    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      margin-bottom: 24px;
    }

    .title-wrap h1 {
      margin: 0;
      font-size: 1.6rem;
      letter-spacing: 0.03em;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .title-pill {
      font-size: 0.75rem;
      padding: 3px 10px;
      border-radius: 999px;
      background: rgba(56, 189, 248, 0.12);
      color: #7dd3fc;
      text-transform: uppercase;
      letter-spacing: 0.09em;
      border: 1px solid rgba(56, 189, 248, 0.3);
    }

    .title-wrap p {
      margin: 4px 0 0;
      font-size: 0.9rem;
      color: var(--text-muted);
    }

    .badge {
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 0.75rem;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(148, 163, 184, 0.4);
      color: var(--text-muted);
      display: inline-flex;
      align-items: center;
      gap: 6px;
      white-space: nowrap;
    }

    .badge-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--accent);
      box-shadow: 0 0 10px rgba(56, 189, 248, 0.9);
    }

    .layout {
      display: grid;
      grid-template-columns: minmax(0, 3fr) minmax(0, 2.2fr);
      gap: 24px;
    }

    @media (max-width: 880px) {
      .layout {
        grid-template-columns: minmax(0, 1fr);
      }
    }

    .card {
      border-radius: 20px;
      background: radial-gradient(circle at top left, #020617 0, #020617 40%, #020617 100%);
      border: 1px solid rgba(148, 163, 184, 0.25);
      padding: 18px 18px 20px;
      position: relative;
      overflow: hidden;
    }

    .card::before {
      content: "";
      position: absolute;
      inset: -40%;
      background:
        radial-gradient(circle at top left, rgba(56, 189, 248, 0.12), transparent 55%);
      opacity: 0.6;
      pointer-events: none;
    }

    .card-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 8px;
      position: relative;
      z-index: 1;
    }

    .card-header h2 {
      margin: 0;
      font-size: 1rem;
      font-weight: 600;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      color: #e5e7eb;
    }

    .card-header small {
      color: var(--text-muted);
      font-size: 0.8rem;
    }

    textarea {
      width: 100%;
      border-radius: 14px;
      padding: 12px 12px 34px;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(148, 163, 184, 0.4);
      color: var(--text);
      font-size: 0.95rem;
      resize: vertical;
      min-height: 160px;
      outline: none;
      position: relative;
      z-index: 1;
    }

    textarea::placeholder {
      color: rgba(148, 163, 184, 0.7);
    }

    .textarea-footer {
      margin-top: 8px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-size: 0.8rem;
      color: var(--text-muted);
      position: relative;
      z-index: 1;
    }

    .counter {
      display: flex;
      gap: 10px;
    }

    .counter span {
      opacity: 0.8;
    }

    .pill-row {
      margin-top: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      font-size: 0.8rem;
    }

    .pill {
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(15, 23, 42, 0.9);
      color: var(--text-muted);
    }

    .button-row {
      margin-top: 14px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      position: relative;
      z-index: 1;
    }

    button {
      border-radius: 999px;
      padding: 8px 16px;
      border: none;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 500;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      transition: transform 0.12s ease, box-shadow 0.12s ease, background 0.12s ease;
    }

    button.primary {
      background: radial-gradient(circle at top, #38bdf8, #0ea5e9);
      color: #0b1120;
      box-shadow:
        0 10px 30px rgba(56, 189, 248, 0.5),
        0 0 0 1px rgba(8, 47, 73, 0.7);
    }

    button.primary:hover {
      transform: translateY(-1px);
      box-shadow:
        0 16px 35px rgba(56, 189, 248, 0.65),
        0 0 0 1px rgba(8, 47, 73, 0.9);
    }

    button.secondary {
      background: rgba(15, 23, 42, 0.96);
      color: var(--text-muted);
      border: 1px solid rgba(148, 163, 184, 0.6);
      box-shadow: 0 0 0 1px rgba(15, 23, 42, 1);
    }

    button.secondary:hover {
      transform: translateY(-1px);
      background: rgba(15, 23, 42, 1);
    }

    .config-row {
      margin-top: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      position: relative;
      z-index: 1;
    }

    .field {
      flex: 1;
      min-width: 180px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    .field label {
      font-size: 0.78rem;
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }

    select,
    input[type="file"] {
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.5);
      background: rgba(15, 23, 42, 0.96);
      color: var(--text);
      padding: 6px 9px;
      font-size: 0.85rem;
      outline: none;
    }

    select:focus,
    input[type="file"]:focus {
      border-color: var(--accent);
    }

    .file-info {
      font-size: 0.78rem;
      color: var(--text-muted);
    }

    /* Score card */
    .score-wrapper {
      position: relative;
      z-index: 1;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      gap: 18px;
    }

    .score-circle-wrap {
      display: flex;
      align-items: center;
      justify-content: center;
      margin-top: 4px;
    }

    .score-circle {
      position: relative;
      width: 160px;
      height: 160px;
      border-radius: 50%;
      background:
        radial-gradient(circle at top, rgba(56, 189, 248, 0.22), transparent 55%),
        conic-gradient(from 210deg, var(--accent) 0deg, var(--accent) 0deg, rgba(30, 64, 175, 1) 0deg);
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow:
        0 0 0 1px rgba(148, 163, 184, 0.25),
        0 18px 45px rgba(15, 23, 42, 0.9);
    }

    .score-circle-inner {
      width: 70%;
      height: 70%;
      border-radius: 50%;
      background: radial-gradient(circle, #020617 0, #020617 40%, #020617 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 4px;
      border: 1px solid rgba(148, 163, 184, 0.3);
    }

    .score-value {
      font-size: 2rem;
      font-weight: 700;
    }

    .score-label {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--text-muted);
    }

    .score-tag {
      margin-top: 4px;
      font-size: 0.8rem;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.4);
    }

    .score-tag.low {
      border-color: var(--danger);
      color: var(--danger);
    }

    .score-tag.medium {
      border-color: var(--warning);
      color: var(--warning);
    }

    .score-tag.high {
      border-color: var(--success);
      color: var(--success);
    }

    .meter {
      width: 100%;
      height: 8px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.95);
      border: 1px solid rgba(148, 163, 184, 0.35);
      overflow: hidden;
      margin-top: 6px;
    }

    .meter-fill {
      height: 100%;
      width: 0%;
      border-radius: inherit;
      background: linear-gradient(90deg, #f97373, #facc15, #4ade80);
      transition: width 0.25s ease-out;
    }

    .score-summary {
      font-size: 0.86rem;
      color: var(--text-muted);
      line-height: 1.5;
    }

    .score-summary strong {
      color: var(--text);
    }

    .metrics-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 6px;
      margin-top: 10px;
      font-size: 0.8rem;
    }

    @media (max-width: 480px) {
      .metrics-grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }

    .metric-box {
      border-radius: 12px;
      padding: 7px 9px;
      background: rgba(15, 23, 42, 0.95);
      border: 1px solid rgba(148, 163, 184, 0.4);
    }

    .metric-label {
      color: var(--text-muted);
      font-size: 0.75rem;
      margin-bottom: 2px;
    }

    .metric-value {
      font-size: 0.9rem;
      font-weight: 500;
    }

    .tips {
      margin-top: 10px;
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    .tips ul {
      margin: 4px 0 0;
      padding-left: 18px;
    }

    .tips li {
      margin: 2px 0;
    }

    /* Backend connection indicator overrides */
    .backend-status .badge-dot {
	transition: background 0.25s ease, box-shadow 0.25s ease;
    }

    .backend-online {
	color: #4ade80 !important;
    }
 
    .backend-online .badge-dot {
  	background: #4ade80 !important;
  	box-shadow: 0 0 10px rgba(74, 222, 128, 0.9);
    }

    .backend-offline {
  	color: #f87171 !important;
    }

    .backend-offline .badge-dot {
  	background: #f87171 !important;
  	box-shadow: 0 0 10px rgba(248, 113, 113, 0.9);
    }

    .backend-checking {
  	color: #38bdf8 !important;
    }

    .backend-checking .badge-dot {
  	background: #38bdf8 !important;
  	box-shadow: 0 0 10px rgba(56,189,248,0.9);
    }

  </style>
</head>
<body>
  <div class="app-shell">
    <div class="header">
      <div class="title-wrap">
        <h1>
          Prompt Energy Efficiency
          <span class="title-pill">LLM Resource Estimator</span>
        </h1>
        <p>Paste a prompt and (optionally) attach a file to estimate a 0–100% eco-efficiency score.</p>
      </div>
      <div id="backendStatus" class="badge backend-status">
  	<span id="backendStatusDot" class="badge-dot"></span>
  	<span id="backendStatusText">Checking backend…</span>
    </div>
</div>

    <div class="layout">
      <!-- LEFT: Prompt input -->
      <div class="card">
        <div class="card-header">
          <div>
            <h2>1. Describe your request</h2>
            <small>We approximate energy use from length, task type, and file size.</small>
          </div>
        </div>
        <textarea
          id="promptInput"
          placeholder="Example: Analyze the attached dataset, run basic correlations, and write a 500-word summary of key trends and caveats."
        ></textarea>

        <div class="config-row">
          <div class="field">
            <label for="taskType">Task type</label>
            <select id="taskType">
              <option value="simple">Simple Q&A / fact lookup</option>
              <option value="chat">Short explanation / chat</option>
              <option value="coding">Coding / debugging</option>
              <option value="math">Math / physics problem solving</option>
              <option value="essay">Essay / long-form writing</option>
              <option value="analysis">Deep analysis of papers / data</option>
            </select>
          </div>
          <div class="field">
            <label for="fileInput">Optional file (for this request)</label>
            <input type="file" id="fileInput" />
            <div class="file-info" id="fileInfo">No file selected.</div>
          </div>
        </div>

        <div class="textarea-footer">
          <div class="counter">
            <span id="wordCount">0 words</span>
            <span id="tokenCount">~0 prompt tokens</span>
          </div>
          <span id="complexityLabel">Complexity: —</span>
        </div>
        <div class="pill-row">
          <span class="pill">Token-heavy prompts & big files = more energy</span>
          <span class="pill">Task type adjusts reasoning complexity</span>
          <span class="pill">Score is relative, not exact CO₂</span>
        </div>
        <div class="button-row">
          <button class="primary" id="scoreButton">
            ⚡ Calculate efficiency
          </button>
          <button class="secondary" id="exampleButton">
            Use a sample prompt
          </button>
        </div>
      </div>

      <!-- RIGHT: Score + breakdown -->
      <div class="card">
        <div class="card-header">
          <div>
            <h2>2. Efficiency score</h2>
            <small>100% = very light; 0% = extremely heavy.</small>
          </div>
        </div>

        <div class="score-wrapper">
          <div class="score-circle-wrap">
            <div class="score-circle" id="scoreCircle">
              <div class="score-circle-inner">
                <div class="score-value" id="scoreValue">—</div>
                <div class="score-label">Efficiency</div>
                <div class="score-tag" id="scoreTag">Awaiting input</div>
              </div>
            </div>
          </div>
          <div class="meter">
            <div class="meter-fill" id="meterFill"></div>
          </div>
          <div class="score-summary" id="scoreSummary">
            Paste a prompt and/or attach a file, then hit
            <strong>“Calculate efficiency”</strong> to see its estimated energy intensity.
          </div>

          <div class="metrics-grid">
            <div class="metric-box">
              <div class="metric-label">Prompt tokens (est.)</div>
              <div class="metric-value" id="metricPromptTokens">~0</div>
            </div>
            <div class="metric-box">
              <div class="metric-label">Total tokens (prompt + file)</div>
              <div class="metric-value" id="metricTotalTokens">~0</div>
            </div>
            <div class="metric-box">
              <div class="metric-label">Token load ratio</div>
              <div class="metric-value" id="metricTokenRatio">0.00</div>
            </div>
            <div class="metric-box">
              <div class="metric-label">Complexity level</div>
              <div class="metric-value" id="metricComplexity">—</div>
            </div>
            <div class="metric-box">
              <div class="metric-label">Complexity ratio</div>
              <div class="metric-value" id="metricComplexityRatio">0.00</div>
            </div>
            <div class="metric-box">
              <div class="metric-label">Attachment load</div>
              <div class="metric-value" id="metricAttachment">None</div>
            </div>
          </div>

          <div class="tips">
            <strong>Make your request “greener” by:</strong>
            <ul>
              <li>Trimming redundant instructions and examples.</li>
              <li>Asking for shorter outputs when essays aren’t necessary.</li>
              <li>Sampling a subset of giant files instead of uploading everything.</li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>

  	<script>
  // ---------- CONFIG ----------
  const BACKEND_URL = "http://localhost:8000"; // your FastAPI server

  const T_MAX = 4000;           // "very heavy" request normalization
  const TOKEN_WEIGHT = 0.7;     // weight of token load in score
  const REASONING_WEIGHT = 0.3; // weight of reasoning complexity

  const TASK_COMPLEXITY = {
    simple: 0.2,
    chat: 0.3,
    coding: 0.5,
    math: 0.6,
    essay: 0.7,
    analysis: 0.9
  };

  const TASK_LABELS = {
    simple: "Simple Q&A / lookup",
    chat: "Short explanation / chat",
    coding: "Coding / debugging",
    math: "Math / physics",
    essay: "Essay / long-form",
    analysis: "Deep analysis / data"
  };

  // ---------- DOM ELEMENTS ----------
  const promptInput = document.getElementById("promptInput");
  const scoreButton = document.getElementById("scoreButton");
  const exampleButton = document.getElementById("exampleButton");
  const taskTypeSelect = document.getElementById("taskType");
  const fileInput = document.getElementById("fileInput");
  const fileInfoEl = document.getElementById("fileInfo");

  const wordCountEl = document.getElementById("wordCount");
  const tokenCountEl = document.getElementById("tokenCount");
  const complexityLabelEl = document.getElementById("complexityLabel");

  const scoreCircle = document.getElementById("scoreCircle");
  const scoreValueEl = document.getElementById("scoreValue");
  const scoreTagEl = document.getElementById("scoreTag");
  const scoreSummaryEl = document.getElementById("scoreSummary");
  const meterFillEl = document.getElementById("meterFill");

  const metricPromptTokensEl = document.getElementById("metricPromptTokens");
  const metricTotalTokensEl = document.getElementById("metricTotalTokens");
  const metricTokenRatioEl = document.getElementById("metricTokenRatio");
  const metricComplexityEl = document.getElementById("metricComplexity");
  const metricComplexityRatioEl = document.getElementById("metricComplexityRatio");
  const metricAttachmentEl = document.getElementById("metricAttachment");

  // ---------- STATE ----------
  let attachmentBytes = 0;
  let attachmentTokens = 0;
  let attachmentTextLength = 0;
  let attachmentSource = "none"; // "backend" | "fallback" | "none"

  let backendAvailable = true; // if backend fails once, we fall back

// Ping the backend to see if it's available
async function checkBackendStatus() {
  const statusEl = document.getElementById("backendStatus");
  const dotEl = document.getElementById("backendStatusDot");
  const textEl = document.getElementById("backendStatusText");

  // set checking state
  statusEl.classList.remove("backend-online", "backend-offline");
  statusEl.classList.add("backend-checking");
  textEl.textContent = "Checking backend…";

  try {
    const res = await fetch(`${BACKEND_URL}/tokenize-text`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ text: "test", model: "gpt-4o" }),
    });

    if (res.ok) {
      backendAvailable = true;
      statusEl.classList.remove("backend-checking", "backend-offline");
      statusEl.classList.add("backend-online");
      textEl.textContent = "Connected · True token counts (tiktoken)";
      return true;
    }
  } catch (e) {
    // ignore
  }

  backendAvailable = false;
  statusEl.classList.remove("backend-checking", "backend-online");
  statusEl.classList.add("backend-offline");
  textEl.textContent = "Offline · Using local fallback estimates";

  return false;
}

  // ---------- HELPERS: Local text stats ----------
  function heuristicTextStats(text) {
    const trimmed = text.trim();
    if (!trimmed) return { words: 0, tokensApprox: 0 };
    const words = trimmed.split(/\s+/).filter(Boolean).length;
    // quick approximate tokens for live display (NOT used for score if backend works)
    const tokensApprox = Math.round(words * 1.3);
    return { words, tokensApprox };
  }

  function estimateKeywordComplexity(prompt) {
    const text = prompt.toLowerCase();
    const length = prompt.trim().split(/\s+/).filter(Boolean).length;

    let level = "Low";
    let numeric = 0.3; // 0–1

    const highKeywords = [
      "essay", "analyze", "analysis", "compare", "contrast",
      "synthesize", "research", "strategy", "plan",
      "multi-step", "multi step", "debate", "proof", "derive", "rigorous"
    ];

    const mediumKeywords = [
      "explain", "why", "how", "step by step", "summarize",
      "interpret", "debug", "refactor", "optimize",
      "calculate", "solve"
    ];

    const hasHigh = highKeywords.some(k => text.includes(k));
    const hasMedium = mediumKeywords.some(k => text.includes(k));

    if (length <= 8 && !hasMedium && !hasHigh) {
      level = "Very low";
      numeric = 0.15;
    } else if (hasHigh || length > 120) {
      level = "High";
      numeric = 0.8;
    } else if (hasMedium || length > 60) {
      level = "Medium";
      numeric = 0.5;
    } else {
      level = "Low";
      numeric = 0.3;
    }

    return { level, ratio: numeric };
  }

  function getCombinedComplexity(prompt) {
    const keyword = estimateKeywordComplexity(prompt);
    const taskType = taskTypeSelect.value;
    const base = TASK_COMPLEXITY[taskType] ?? 0.3;

    const combinedRatio = (keyword.ratio + base) / 2;
    let level;
    if (combinedRatio < 0.25) level = "Very low";
    else if (combinedRatio < 0.45) level = "Low";
    else if (combinedRatio < 0.7) level = "Medium";
    else level = "High";

    return {
      level,
      ratio: combinedRatio,
      taskType
    };
  }

  function humanFileSize(bytes) {
    if (!bytes) return "0 B";
    const units = ["B", "KB", "MB", "GB", "TB"];
    let i = 0;
    let num = bytes;
    while (num >= 1024 && i < units.length - 1) {
      num /= 1024;
      i++;
    }
    return `${num.toFixed(1)} ${units[i]}`;
  }

  function classifyScoreTag(score) {
    if (isNaN(score)) return { text: "Awaiting input", cls: "" };
    if (score >= 75) return { text: "High efficiency", cls: "high" };
    if (score >= 45) return { text: "Moderate efficiency", cls: "medium" };
    return { text: "Low efficiency", cls: "low" };
  }

  // ---------- HELPERS: Backend calls ----------
  async function getPromptTokensFromBackend(text) {
    if (!backendAvailable || !text.trim()) return null;
    try {
      const res = await fetch(`${BACKEND_URL}/tokenize-text`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ text, model: "gpt-4o" })
      });
      if (!res.ok) throw new Error("Bad response");
      const data = await res.json();
      return data.token_count ?? null;
    } catch (e) {
      console.warn("Backend text tokenization failed, falling back to heuristic.", e);
      backendAvailable = false;
      return null;
    }
  }

  async function getFileTokensFromBackend(file) {
    if (!backendAvailable || !file) return null;
    try {
      const formData = new FormData();
      formData.append("file", file);
      formData.append("model", "gpt-4o");

      const res = await fetch(`${BACKEND_URL}/tokenize-file`, {
        method: "POST",
        body: formData
      });
      if (!res.ok) throw new Error("Bad response");
      const data = await res.json();
      return {
        token_count: data.token_count ?? 0,
        byte_size: data.byte_size ?? file.size,
        text_length: data.text_length ?? 0
      };
    } catch (e) {
      console.warn("Backend file tokenization failed, falling back to heuristic.", e);
      backendAvailable = false;
      return null;
    }
  }

  // ---------- UI UPDATE HELPERS ----------
  function updateAttachmentMetricDisplay() {
    if (attachmentBytes === 0 || attachmentSource === "none") {
      metricAttachmentEl.textContent = "None";
      return;
    }
    const sizeStr = humanFileSize(attachmentBytes);
    const tokensStr = attachmentTokens.toLocaleString();
    const srcLabel = attachmentSource === "backend" ? "backend (exact tokenizer)" : "fallback estimate";
    metricAttachmentEl.textContent = `${sizeStr} → ≈ ${tokensStr} tokens (${srcLabel})`;
  }

  function updateTextStatsLive() {
    const val = promptInput.value;
    const { words, tokensApprox } = heuristicTextStats(val);
    const complexity = getCombinedComplexity(val);

    wordCountEl.textContent = `${words} ${words === 1 ? "word" : "words"}`;
    tokenCountEl.textContent = `~${tokensApprox} prompt tokens (approx)`;

    if (words === 0 && !attachmentBytes) {
      complexityLabelEl.textContent = "Complexity: —";
    } else {
      const taskLabel = TASK_LABELS[taskTypeSelect.value] || "Custom";
      complexityLabelEl.textContent = `Complexity: ${complexity.level} (Task: ${taskLabel})`;
    }
  }

  function handleFileSelectionChange() {
    const file = fileInput.files && fileInput.files[0];
    if (!file) {
      attachmentBytes = 0;
      attachmentTokens = 0;
      attachmentTextLength = 0;
      attachmentSource = "none";
      fileInfoEl.textContent = "No file selected.";
      updateAttachmentMetricDisplay();
      return;
    }
    attachmentBytes = file.size;
    attachmentTokens = 0;
    attachmentTextLength = 0;
    attachmentSource = "none";

    const sizeStr = humanFileSize(attachmentBytes);
    fileInfoEl.textContent = `${file.name} · ${sizeStr} · tokens will be computed when you click “Calculate efficiency”.`;
    updateAttachmentMetricDisplay();
  }

  // ---------- MAIN: Calculate efficiency ----------
  async function calculateEfficiency() {
    const prompt = promptInput.value || "";
    const file = fileInput.files && fileInput.files[0];

    const hasAnyInput = prompt.trim() || file;
    if (!hasAnyInput) {
      scoreValueEl.textContent = "—";
      meterFillEl.style.width = "0%";
      scoreTagEl.textContent = "Awaiting input";
      scoreTagEl.className = "score-tag";
      scoreSummaryEl.innerHTML =
        'Paste a prompt and/or attach a file, then hit <strong>“Calculate efficiency”</strong>.';
      metricPromptTokensEl.textContent = "~0";
      metricTotalTokensEl.textContent = "~0";
      metricTokenRatioEl.textContent = "0.00";
      metricComplexityEl.textContent = "—";
      metricComplexityRatioEl.textContent = "0.00";
      metricAttachmentEl.textContent = "None";
      return;
    }

    // 1) Complexity from prompt + task type
    const complexity = getCombinedComplexity(prompt);
    const taskLabel = TASK_LABELS[complexity.taskType] || "Custom";

    // 2) Get token counts (backend if possible, else heuristic)
    const { tokensApprox: promptTokensApprox } = heuristicTextStats(prompt);

    let promptTokens = promptTokensApprox;
    let promptSource = "fallback";

    if (backendAvailable && prompt.trim()) {
      const backendTokens = await getPromptTokensFromBackend(prompt);
      if (backendTokens !== null) {
        promptTokens = backendTokens;
        promptSource = "backend";
      }
    }

    // File tokens
    attachmentTokens = 0;
    attachmentTextLength = 0;
    attachmentSource = "none";

    if (file) {
      if (backendAvailable) {
        const backendFile = await getFileTokensFromBackend(file);
        if (backendFile) {
          attachmentTokens = backendFile.token_count;
          attachmentBytes = backendFile.byte_size;
          attachmentTextLength = backendFile.text_length;
          attachmentSource = "backend";
        } else {
          // simple fallback if backend failed during this call
          attachmentBytes = file.size;
          attachmentTokens = Math.round(file.size / 32); // gentle rough estimate
          attachmentTextLength = 0;
          attachmentSource = "fallback";
        }
      } else {
        attachmentBytes = file.size;
        attachmentTokens = Math.round(file.size / 32);
        attachmentTextLength = 0;
        attachmentSource = "fallback";
      }
    }

    const totalTokens = promptTokens + attachmentTokens;
    const tokenRatio = Math.min(totalTokens / T_MAX, 1);

    const computeIntensity =
      TOKEN_WEIGHT * tokenRatio + REASONING_WEIGHT * complexity.ratio;

    const efficiencyRaw = 1 - computeIntensity;
    const efficiency = Math.max(0, Math.min(efficiencyRaw * 100, 100));
    const roundedScore = Math.round(efficiency);

    // ---------- Update score UI ----------
    scoreValueEl.textContent = `${roundedScore}%`;
    const tagInfo = classifyScoreTag(roundedScore);
    scoreTagEl.textContent = tagInfo.text;
    scoreTagEl.className = `score-tag ${tagInfo.cls}`;

    const degrees = (roundedScore / 100) * 360;
    scoreCircle.style.background = `
      radial-gradient(circle at top, rgba(56, 189, 248, 0.22), transparent 55%),
      conic-gradient(
        from 210deg,
        var(--accent) 0deg,
        var(--accent) ${degrees}deg,
        rgba(30, 64, 175, 1) ${degrees}deg
      )
    `;

    meterFillEl.style.width = `${roundedScore}%`;

    let attachmentLine = "Attachment: none.";
    if (attachmentBytes > 0) {
      const sizeStr = humanFileSize(attachmentBytes);
      const src =
        attachmentSource === "backend"
          ? "backend tokenizer"
          : "fallback estimate";
      attachmentLine =
        `Attachment: ${sizeStr}, ≈ ${attachmentTokens.toLocaleString()} tokens (${src}).`;
    }

    const promptSourceLabel =
      promptSource === "backend"
        ? "backend tokenizer (tiktoken)"
        : "local approximation";

    scoreSummaryEl.innerHTML = `
      This request is estimated to be <strong>${roundedScore}% efficient</strong> for an LLM to process.
      The score blends <strong>${Math.round(
        TOKEN_WEIGHT * 100
      )}% token load</strong> (prompt text + file, total ≈ ${totalTokens.toLocaleString()} tokens)
      and <strong>${Math.round(
        REASONING_WEIGHT * 100
      )}% reasoning complexity</strong> (task type: ${taskLabel}).<br>
      <span style="opacity:0.85;">Prompt tokens from ${promptSourceLabel}. ${attachmentLine}</span>
    `;

    // ---------- Update metrics ----------
    metricPromptTokensEl.textContent = `~${promptTokens.toLocaleString()}`;
    metricTotalTokensEl.textContent = `~${totalTokens.toLocaleString()}`;
    metricTokenRatioEl.textContent = tokenRatio.toFixed(2);
    metricComplexityEl.textContent = complexity.level;
    metricComplexityRatioEl.textContent = complexity.ratio.toFixed(2);
    updateAttachmentMetricDisplay();

    // Update small live token display with the better number if backend used
    if (promptSource === "backend") {
      tokenCountEl.textContent = `≈${promptTokens} prompt tokens (backend)`;
    }
  }

  // ---------- EVENT LISTENERS ----------
  promptInput.addEventListener("input", updateTextStatsLive);
  taskTypeSelect.addEventListener("change", updateTextStatsLive);
  fileInput.addEventListener("change", handleFileSelectionChange);

  scoreButton.addEventListener("click", () => {
    calculateEfficiency().catch(err => {
      console.error("Error calculating efficiency:", err);
      alert("Something went wrong calculating the score. Check the console for details.");
    });
  });

  exampleButton.addEventListener("click", () => {
    const sample =
      "You are an AI assistant helping me with climate policy. " +
      "Using the attached CSV of emissions by sector and year, identify the top 3 sectors driving recent increases, " +
      "run basic trend analysis, and write a 500–600 word explanation of the patterns and their policy implications.";
    promptInput.value = sample;
    updateTextStatsLive();
  });

  // ---------- INIT ----------
  updateTextStatsLive();
  handleFileSelectionChange();

// check once on load
checkBackendStatus();

// re-check periodically (every 10 seconds)
setInterval(checkBackendStatus, 10000);

</script>

</body>
</html>

